#!/usr/bin/env python
import os
from optparse import OptionParser
from ConfigParser import SafeConfigParser

## Global variables
flags = ""
outputFile = ""
directory = ""
compiler = ""
installPath = ""
configOptions = {}

def parseCommandline():
    global flags, outputFile, directory, compiler, installPath
    # Get commandline arguments
    parser = OptionParser(usage="Usage: pymake.py [ -c Compiler ] [ -d Source Directory ] [ -f \"Flags\" ] [ -i Install Directory ] [ -o Output File ]", version="PyMake Version 0.3")
    parser.add_option("-f", "--flags", dest="flags", help="flags for the compiler and typed within quotes", default="") 
    parser.add_option("-o", dest="outputFile", help="output file name from compiler. Default: a.out", default="a.out") 
    parser.add_option("-d", "--directory", dest="directory", help="directory for pymake to create Makefile for. Default: ./", default="./") 
    parser.add_option("-c", "--compiler", dest="compiler", help="set compiler to use. Default: PyMake will look at your files and guess", default="") 
    parser.add_option("-i", "--install-dir", dest="installPath", help="directory for 'make install'. Default: /usr/local/bin", default="/usr/local/bin") 
    (options, args) = parser.parse_args()
    outputFile = options.outputFile
    flags = options.flags
    directory = options.directory
    compiler = options.compiler
    installPath = options.installPath

def parseConfig(fileType):
    global flags, compiler, installPath
    conf = SafeConfigParser()
    f = conf.read(os.path.expanduser("~/pymake.cfg"))
    if len(f) == 0:
        return False
    confFlags = confCompiler = confInstallDir = ""
    try:
      confFlags = conf.get(fileType, "flags")
    except:
        pass 
    try:
        confCompiler = conf.get(fileType, "compiler")
    except:
        pass 
    try:
        confInstallDir = conf.get(fileType, "installPath")
    except:
        pass
    if len(confFlags) != 0 :
        flags = confFlags
    if len(confCompiler) != 0:
        compiler = confCompiler
    if len(confInstallDir) != 0:
        installPath = confInstallDir
    return True


def files():
    allFiles = [f for f in os.listdir('.') if os.path.isfile(f)]
    sourceFiles = []
    for f in allFiles:
        if "." in f and isSourceFile(f):
            sourceFiles.append(f)
    return sourceFiles

# Checks to see if the file extention should be included in file list for compiler
def isSourceFile(fileName):
    if fileName.startswith("."):
        return False 
    elif fileName.split(".")[-1] in ["plist", "out", "log", "zip", "gz", "h", "hpp", "hxx", "hh", "db", "md", "sh", "txt", "pdf", "doc", "html"]:
        return False
    return True

def typeOfFile(fileName):
    return fileName[(fileName.index('.'))+1:]

def baseFileName(fileName):
    return fileName[:(fileName.index('.'))]

def compilerName(fileType):
    if fileType == "c" or fileType == "s" or fileType == "asm":
        return "gcc"
    elif fileType == "cpp" or fileType == "cxx" or fileType == "cp" or fileType == "cc":
        return "g++"
    elif fileType == "f" or fileType == "F" or fileType == "FOR":
        return "gfortran"
    elif fileType == "go":
        return "go build"
    else:
        print("File type '" + fileType + "' not supported yet. Defaulting to gcc.")
        return "gcc"

def flagsForCompiler(compilerName):
    compilerVarName = ""
    compilerFlagsName = ""
    
    if compilerName == "g++":
        compilerVarName = "CXX"
        compilerFlagsName = "CXXFLAGS"
    elif compilerName == "gfortran":
        compilerVarName = "FF"
        compilerFlagsName = "FFLAGS"
    elif compilerName == "go build":
        compilerVarName = "GC"
        compilerFlagsName = "GCFLAGS"
    else:
        # Default to gcc with C setup
        compilerVarName = "CC"
        compilerFlagsName = "CFLAGS"

    flagVars =  compilerVarName + " := " + compilerName + "\n"
    flagVars += compilerFlagsName + " := " + flags + "\n" 
    ## Use PYMAKE_COMPILER_FLAGS and PYMAKE_COMPILER to keep it track of compiler and flags for internal use
    flagVars += "PYMAKE_COMPILER := $(" + compilerVarName + ")\n"
    flagVars += "PYMAKE_COMPILER_FLAGS := $(" + compilerFlagsName + ")\n"
    return flagVars 



def generateFileContents(fileNames, compilerName):
    fileContents = "# Generated by pymake version 0.3\n# PyMake was written by Stephen Melinyshyn | github.com/Melinysh/PyMake\n\n"
   
    # Compiler specific variables
    fileContents += flagsForCompiler(compilerName)

    fileContents += "INSTALL_PATH := " + installPath + "\n"
    fileContents += "TARGET := " + outputFile + "\n"
    fileContents += "OBJECTS := " + fileNames + "\n\n"

    fileContents += "all: $(TARGET)\n\n"
    fileContents += "$(TARGET): $(OBJECTS)\n"
    fileContents += "\t$(PYMAKE_COMPILER) $(PYMAKE_COMPILER_FLAGS) -o $(TARGET) $(OBJECTS)\n"
    
    ## Install
    fileContents += "\n"
    fileContents += "install: $(TARGET)\n"
    fileContents += "\tinstall $(TARGET) $(INSTALL_PATH)\n"

    ## Uninstall
    fileContents += "\n"
    fileContents += "uninstall:\n"
    fileContents += "\t-rm $(INSTALL_PATH)/$(TARGET)\n"

    ## Clean
    fileContents += "\n"
    fileContents += "clean:" + "\n"
    fileContents += "\t" + "-rm $(TARGET)\n"

    return fileContents 

def writeToMakefile(fileContents):
    makefile = open("Makefile", 'w')
    makefile.write(fileContents)
    makefile.close()

def start():
    global compiler, fileType
    parseCommandline()
    os.chdir(directory)
    fileList = files()
    if len(fileList) == 0:
        print("Whoops! PyMake can't find any files that would belong in a Makefile.")
        print("Are you sure you're in the right directory?")
        exit(1)
    fileContents = ""
    fileNames = ""
    for f in fileList:
        fileNames += f + " "
    fileType = typeOfFile(fileList[0])
    if compiler == "":
        compiler = compilerName(fileType)
    parseConfig(fileType)
    fileContents = generateFileContents(fileNames, compiler)
    writeToMakefile(fileContents)
    exit(0)

start()
